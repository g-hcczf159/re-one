<!DOCTYPE html>
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>æ‰«é›·</title>
		<style>
			body {
				display: flex;
				flex-direction: column;
				align-items: center;
				justify-content: center;
				min-height: 100vh;
				margin: 0;
				background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
				font-family: "Microsoft YaHei", Arial, sans-serif;
				padding: 20px;
			}

			.game-container {
				background: white;
				padding: 25px;
				border-radius: 20px;
				box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 20px;
			}

			h1 {
				color: #2c3e50;
				margin: 0;
				font-size: 28px;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
			}

			p {
				color: #7f8c8d;
				margin: 5px 0 15px 0;
				font-size: 16px;
			}

			#gnav {
				background-color: #f8f9fa;
				padding: 15px 25px;
				border-radius: 15px;
				box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
				margin-bottom: 15px;
				display: flex;
				flex-wrap: wrap;
				gap: 10px;
				justify-content: center;
				align-items: center;
				width: auto;
				min-width: 280px;
			}

			.game-stats {
				display: flex;
				gap: 15px;
				margin-bottom: 10px;
				width: 100%;
				justify-content: center;
			}

			.stat-container {
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 5px;
			}

			.stat-label {
				font-size: 12px;
				color: #666;
				text-transform: uppercase;
			}

			#mine-total, #timer {
				width: 60px;
				text-align: center;
				padding: 8px;
				border: 2px solid #3498db;
				border-radius: 8px;
				font-size: 16px;
				font-weight: bold;
				color: #2c3e50;
				background: white;
				box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
			}

			.difficulty-controls {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				justify-content: center;
			}

			label {
				padding: 8px 16px;
				background-color: #f1f3f5;
				border-radius: 25px;
				cursor: pointer;
				transition: all 0.3s ease;
				font-size: 14px;
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
			}

			input[type="radio"]:checked + label {
				background-color: #3498db;
				color: white;
				box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
			}

			#btn {
				background-color: #2ecc71;
				color: white;
				border: none;
				padding: 10px 25px;
				border-radius: 25px;
				cursor: pointer;
				transition: all 0.3s ease;
				font-size: 15px;
				font-weight: bold;
				margin-top: 10px;
				width: auto;
			}

			#mycanv {
				border-radius: 15px;
				box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
				background-color: white;
				margin: 10px 0;
			}

			.modal-overlay {
				display: none;
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.5);
				z-index: 1000;
				justify-content: center;
				align-items: center;
			}

			.modal-content {
				background-color: #fff;
				padding: 40px;
				border-radius: 20px;
				box-shadow: 0 4px 30px rgba(0, 0, 0, 0.2);
				text-align: center;
				animation: modalFadeIn 0.3s ease-out;
				max-width: 400px;
				width: 90%;
			}

			.modal-title {
				font-size: 24px;
				margin-bottom: 15px;
				color: #333;
			}

			.modal-message {
				font-size: 18px;
				margin-bottom: 25px;
				color: #666;
			}

			.modal-button {
				background-color: #3498db;
				padding: 12px 35px;
				font-size: 16px;
				font-weight: bold;
				letter-spacing: 1px;
				color: white;
				border: none;
				border-radius: 25px;
				cursor: pointer;
				transition: all 0.3s ease;
			}

			.modal-button:hover {
				background-color: #2980b9;
				transform: translateY(-2px);
				box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
			}

			.win-message {
				color: #2ecc71;
			}

			.lose-message {
				color: #e74c3c;
			}

			@keyframes modalFadeIn {
				from {
					opacity: 0;
					transform: translateY(-20px);
				}
				to {
					opacity: 1;
					transform: translateY(0);
				}
			}

			/* æ›´æ–°å“åº”å¼è®¾è®¡ */
			@media (max-width: 768px) {
				.game-container {
					padding: 15px;
					width: 95%;
					max-width: 500px;
				}

				#gnav {
					padding: 12px;
					flex-direction: column;
				}

				.game-stats {
					flex-direction: row;
					justify-content: space-around;
				}

				.difficulty-controls {
					width: 100%;
				}

				label {
					padding: 6px 12px;
					font-size: 13px;
				}

				#btn {
					width: 100%;
					margin: 5px 0;
				}
			}
		</style>
	</head>
	<body>
		<div class="game-container">
			<h1>æ‰«é›·æ¸¸æˆ</h1>
			<p>ç‚¹å‡»å¼€å§‹ä½ çš„æ‰«é›·ä¹‹æ—…</p>
			<div id="gnav">
				<div class="game-stats">
					<div class="stat-container">
						<span class="stat-label">å‰©ä½™é›·æ•°</span>
						<input type="text" id="mine-total" readonly />
					</div>
					<div class="stat-container">
						<span class="stat-label">ç”¨æ—¶</span>
						<input type="text" id="timer" readonly />
					</div>
				</div>
				<div class="difficulty-controls">
					<input type="radio" name="level" id="level_1" onchange="select_lev(0)" checked="checked" />
					<label for="level_1">åˆçº§</label>
					<input type="radio" name="level" id="level_2" onchange="select_lev(1)" />
					<label for="level_2">ä¸­çº§</label>
					<input type="radio" name="level" id="level_3" onchange="select_lev(2)" />
					<label for="level_3">é«˜çº§</label>
				</div>
				<button id="btn" onclick="select_lev()">é‡æ–°å¼€å§‹</button>
			</div>
			<canvas id="mycanv"></canvas>
		</div>
		<div class="modal-overlay" id="gameOverModal">
			<div class="modal-content">
				<h2 class="modal-title" id="modalTitle"></h2>
				<p class="modal-message" id="modalMessage"></p>
				<button class="modal-button" id="restartButton">é‡æ–°å¼€å§‹</button>
			</div>
		</div>
		<script>
			/**@type{HTMLCanvasElement}*/ //vsCode
			var gnav = document.getElementById('gnav');
			var mine_total = document.getElementById('mine-total');
			var mine_timer = document.getElementById('timer');
			var canv = document.getElementById('mycanv');
			var ctx = canv.getContext('2d');
			//æ¸¸æˆç­‰çº§ä¿¡æ¯
			var levels = [
				[9, 9, 10],
				[16, 16, 40],
				[16, 30, 99],
			];
			//é¢„è®¾æ¸¸æˆç­‰çº§0
			var level = 0;
			var g = levels[level];//å½“å‰æ¸¸æˆç­‰çº§ä¿¡æ¯
			var g_arr = [];//æ¸¸æˆå—idåˆ—è¡¨
			var g_info = {};//æ¯ä¸ªå—çš„æ¸¸æˆä¿¡æ¯
			var g_color = {//é¢„è®¾æ¸¸æˆå—é¢œè‰²
				block: '#369',
				open: '#ddd',
				mine: '#69f',
				bomb: '#f66',
				highlight: '#69d',
			};
			var mine_arr = [];//å½“å‰æ¸¸æˆé›·å—idåˆ—è¡¨
			var count = 0;//å·²æ ‡è®°é›·å—ç»Ÿè®¡
			var over = false;//æ¸¸æˆæ˜¯å¦ç»“æŸ
			var win = false;//æ¸¸æˆæ˜¯å¦è·èƒœ
			var XY = '';//æ„é€ xy
			var gblock = {//å¸ƒå±€,æ¸¸æˆå—å°ºå¯¸:å®½åº¦,åœ†è§’,å¤–è¾¹è·
				width: 50,
				radius: 6,
				margin: 2,
			};
			var mine = ['ğŸ’£', 'ğŸš©', 'â”', 'ğŸ’¥'];//é¢„è®¾é›·å—æ ‡è®°ç¬¦å·
			var gamestart = 0;//æ¸¸æˆæ˜¯å¦å¼€å§‹
			var ttimer = 0;//æ¸¸æˆè®¡æ—¶å™¨
			var durtime = 0;//æ¸¸æˆè€—æ—¶è®°å½•
			g_init();
			//åˆå§‹åŒ–
			function g_init() {
				//------é‡ç½®æ¸¸æˆåŸºç¡€ä¿¡æ¯------
				g_arr = [];
				mine_arr = [];
				count = 0;
				over = false;
				win = false;
				gamestart = 0;
				durtime = 0;
				clearInterval(ttimer);//æ¸…é™¤å®šæ—¶å™¨
				
				g = levels[level];//è·å–æ¸¸æˆç­‰çº§,é‡ç½®æ¸¸æˆç”»å¸ƒåŠç›¸å…³æ¸¸æˆæ•°æ®
				
				// æ›´æ–°å¯¼èˆªæ å®½åº¦å’Œæ¸¸æˆæ•°æ®
				gnav.style.width = g[1] * gblock.width + 'px';
				mine_total.value = g[2];
				mine_timer.value = 0;
				
				// è®¾ç½®ç”»å¸ƒå°ºå¯¸
				let h = g[0] * gblock.width;
				let w = g[1] * gblock.width;
				canv.height = h;
				canv.width = w;
				ctx.clearRect(0, 0, w, h);//æ¸…é™¤ç”»å¸ƒ
				
				// é‡ç½®æ¸¸æˆä¿¡æ¯å¯¹è±¡
				g_info = {};
				
				//æŒ‰è¡Œåˆ—è¾“å‡ºæ¸¸æˆå—
				for (let i = 0; i < g[0]; i++) {
					for (let j = 0; j < g[1]; j++) {
						let xy = j + '-' + i;//æ ¹æ®åæ ‡æ„é€ æ¸¸æˆå—id
						g_arr.push(xy);//g_arrè®°å½•æ¸¸æˆå—id
						g_info[xy] = {//å¯¹æ¯ä¸ªæ¸¸æˆå—, é¢„è®¾æ¸¸æˆä¿¡æ¯: 
							mark: 0,//mark:æ•°å­—æ ‡è®°0-8æˆ–é›·æ ‡è®°-1;
							open: 0,//open:æ¸¸æˆå—æ‰“å¼€çŠ¶æ€:0æœªæ‰“å¼€/1å·²æ‰“å¼€/-1æ ‡è®°é›·å—/-2ç–‘ä¼¼é›·å—
						};
						drawBlock(xy, g_color.block);//ç»˜åˆ¶: å—,é¢œè‰²
					}
				}
				initTouchEvents();
			}

			function select_lev(lv) {//é€‰æ‹©æ¸¸æˆç­‰çº§
				if (lv !== undefined) {
					level = lv;  // åªæœ‰åœ¨æ˜ç¡®ä¼ å…¥éš¾åº¦æ—¶æ‰æ›´æ–°level
				}
				g_init();
			}

			function drawBlock(xy, c) {//ç»˜åˆ¶æ¸¸æˆå—: åœ†è§’çŸ©å½¢
				let [x, y] = xy.split('-').map(n => n * gblock.width);//è§£æid,å¹¶æ„é€ åæ ‡
				let w = gblock.width - gblock.margin;
				let r = gblock.radius;
				ctx.clearRect(x, y, gblock.width, gblock.width); 
				ctx.save();
				ctx.beginPath();
				ctx.moveTo(x, y + gblock.radius);
				ctx.arcTo(x, y + w, x + w, y + w, r);
				ctx.arcTo(x + w, y + w, x + w, y, r);
				ctx.arcTo(x + w, y, x, y, r);
				ctx.arcTo(x, y, x, y + w, r);
				ctx.closePath();
				ctx.fillStyle = c;
				ctx.fill();
				ctx.restore();
			}

			function setMine(excludeXY) {//éšæœºå¸ƒé›·: ç”Ÿæˆé›·å—åˆ—è¡¨mine_arr,æ›´æ–°æ¸¸æˆå—ä¿¡æ¯g_info:æ ‡è®°ä¸ºé›·æˆ–è®¡ç®—æ•°å­—
				// åˆ›å»ºå¯ç”¨äºå¸ƒé›·çš„ä½ç½®æ•°ç»„ï¼ˆæ’é™¤ç¬¬ä¸€æ¬¡ç‚¹å‡»çš„ä½ç½®åŠå…¶å‘¨å›´ï¼‰
				let availablePositions = g_arr.filter(xy => {
					if (xy === excludeXY) return false;
					// æ’é™¤ç¬¬ä¸€æ¬¡ç‚¹å‡»ä½ç½®å‘¨å›´çš„8ä¸ªæ ¼å­
					return !getAround(excludeXY).includes(xy);
				});
				
				// éšæœºé€‰æ‹©ä½ç½®å¸ƒé›·
				mine_arr = availablePositions
					.sort(() => Math.random() - 0.5)
					.slice(0, g[2]);

				// æ”¾ç½®åœ°é›·å¹¶è®¡ç®—å‘¨å›´æ•°å­—
				mine_arr.forEach(xy => {
					g_info[xy].mark = -1;//å°†æ¸¸æˆå—æ ‡è®°ä¸ºé›·-1
					getAround(xy).forEach(n => {//è·å–å½“å‰é›·å—å‘¨è¾¹8å—: è®¡ç®—æ•°å­—
						if (g_info[n].mark != -1) g_info[n].mark++;//æ¯å¸ƒä¸€ä¸ªé›·,å¯¹äºå‘¨è¾¹éé›·å—æ•°å­—+1
					});
				});
			}

			function getAround(xy) {//è·å–å½“å‰æ¸¸æˆå—çš„å‘¨è¾¹æœ‰æ•ˆå—
				let [x, y] = xy.split('-').map(n => n * 1);
				let around = [];
				//å·¦ä¸­å³,ä¸Šä¸­ä¸‹
				for (let i = -1; i <= 1; i++) {
					for (let j = -1; j <= 1; j++) {
						//æ„é€ æ¸¸æˆå—id
						let id = `${x + i}-${y + j}`;
						//åˆ¤æ–­idæ˜¯å¦æœ‰æ•ˆ:åœ¨æ¸¸æˆå—æ•°ç»„g_arrä¸­åŒ…å«, å¹¶æ’é™¤è‡ªèº«å—;
						if (g_arr.includes(id) && id != xy) around.push(id);
					}
				}
				return around;
			}

			function markText(xy, text) {
				let [x, y] = xy.split('-').map(n => n * gblock.width);
				ctx.save();
				ctx.fillStyle = '#111';
				ctx.font = '20px arial';
				ctx.textAlign = 'center';
				ctx.textBaseline = 'middle';
				// åªåœ¨æ•°å­—ä¸ä¸º0æ—¶æ˜¾ç¤ºæ–‡æœ¬
				if (text !== 0) {
					ctx.fillText(text, x + gblock.width / 2, y + gblock.width / 2);
				}
				ctx.restore();
			}
			//è¾…åŠ©æ˜¾ç¤º
			function showInfo() {//è¾…åŠ©æ˜¾ç¤ºå¸ƒé›·æƒ…å†µä¿¡æ¯, æ˜¾ç¤ºæ•°å­—å’Œé›·å—æ ‡è®°
				g_arr.forEach(xy => {
					if (g_info[xy].mark == -1) {
						drawBlock(xy, g_color.mine);
					} else {
						//æ˜¾ç¤ºæ•°å­—
						drawBlock(xy, g_color.block);
						markText(xy, g_info[xy].mark);
					}
				});
			}
			//é¼ æ ‡äº‹ä»¶:
			//1,å·¦é”®ç‚¹å‡»click(æœªæ‰“å¼€å—)æ‰“å¼€æ¸¸æˆå—(æ™®é€šæ•°å­—å—,ç©ºç™½åŒºé€’å½’æ¸…é›¶,é›·å—è§¦é›·å¤±è´¥)
			//2,å³é”®ç‚¹å‡»contextmenu(æœªæ‰“å¼€å—)æ ‡è®°æ¸¸æˆå—(æ ‡è®°é›·å—,æ ‡è®°ç–‘ä¼¼é›·å—,å–æ¶ˆæ ‡è®°)
			//3,ç‚¹å‡»å·²æ‰“å¼€çš„å—: mousedownæŒ‰ä¸‹é¼ æ ‡é«˜äº®å‘¨è¾¹; mouseupæ¾å¼€é¼ æ ‡å–æ¶ˆé«˜äº®,*è¾…åŠ©æ‰«é›·;
			canv.addEventListener('click', openBlock);
			canv.addEventListener('contextmenu', markMine);
			canv.addEventListener('mousedown', highLight);
			canv.addEventListener('mouseup', supGame);

			function highLight(ev) {//å³å‡»éé›·å—,è¾…åŠ©: é«˜äº®å‘¨è¾¹
				if (over) return;
				//è·å–æ­£ç¡®åæ ‡
				let x = ~~(ev.offsetX / gblock.width);
				let y = ~~(ev.offsetY / gblock.width);
				let xy = x + '-' + y;
				if (g_info[xy].open == 1) getAround(xy).forEach(n => {
					if (g_info[n].open == 0) {
						drawBlock(n, g_color.highlight);
					}
				});
			}

			function startTimer() {//æ¸¸æˆå¼€å§‹è®¡æ—¶
				ttimer = setInterval(() => {
					durtime++;
					mine_timer.value = (durtime / 10).toFixed(1);
				}, 100);
			}

			function supGame(ev) {//å³å‡»éé›·å—,è¾…åŠ©: é¼ æ ‡æŒ‰ä¸‹é«˜äº®,é¼ æ ‡æ¾å¼€å–æ¶ˆé«˜äº®å¹¶æ ‡æ³¨ç¡®å®šçš„æ¸¸æˆå—(æ‰“å¼€æˆ–æ ‡è®°é›·)
				if (over) return;
				//è·å–æ­£ç¡®åæ ‡
				let x = ~~(ev.offsetX / gblock.width);
				let y = ~~(ev.offsetY / gblock.width);
				let xy = x + '-' + y;
				if (g_info[xy].open == 1) {
					let around = getAround(xy);//è·å–å½“å‰æ¸¸æˆå—å‘¨è¾¹
					let mark = g_info[xy].mark;
					let marked_mine = 0;//å·²æ ‡è®°é›·å—æ•°é‡
					let unopen = 0;//æœªæ‰“å¼€å—æ•°é‡
					around.forEach(n => {//ç»Ÿè®¡å‘¨è¾¹æ¸¸æˆå—ä¿¡æ¯: æœªæ‰“å¼€å—æ•°é‡å’Œå·²æ ‡è®°é›·æ•°é‡
						if (g_info[n].open == 0 || g_info[n].open == -2) unopen++;
						if (g_info[n].open == -1) marked_mine++;
					});
					around.forEach(n => {//éå†å‘¨è¾¹å—,
						if (g_info[n].open == 0) {
							drawBlock(n, g_color.block);//å–æ¶ˆé«˜äº®
							//è¾…åŠ©æ‰«é›·
							if (mark == marked_mine) {//å¦‚æœå½“å‰æ•°å­—ç­‰äºå·²ç»æ ‡è®°çš„é›·å—:é›·å·²ç»å…¨éƒ¨æ’å‡º, å…¶ä»–ä¸ºå®‰å…¨å—
								g_info[n].open = 1;//å®‰å…¨å—,è‡ªåŠ¨æ‰“å¼€
								drawBlock(n, g_color.open);
								markText(n, g_info[n].mark);
								if (g_info[n].mark == 0) openZero(n);//å¦‚æœæ˜¯0å—, é€’å½’æ¸…é›¶(0å—è¯´æ˜å‘¨è¾¹æ²¡æœ‰é›·)
								if (g_info[n].mark == -1) {//åœ¨å®‰å…¨å—ä¸­é‡åˆ°é›·(è¯´æ˜æ ‡è®°äº†é”™è¯¯é›·å—)
									drawBlock(n, g_color.bomb);
									markText(n, mine[0]);
									markText(n, mine[3]);
									checkOver(true);//æ¸¸æˆç»“æŸ
								}
							} else if (unopen == mark - marked_mine) {//å¦‚æœå‰©ä½™çš„å—éƒ½æ˜¯é›·, åˆ™ç›´æ¥æ ‡æ³¨é›·
								g_info[n].open = -1;
								drawBlock(n, g_color.mine);
								markText(n, mine[1]);
								count++;
								mine_total.value = g[2] - count;
								if (count == g[2]) checkOver();//æ ‡è®°é›·ä¹‹å, åˆ¤æ–­æ•°é‡, æ˜¯å¦å®Œæˆæ‰«é›·
							}
						}
					});
				}
			}

			function openBlock(ev) {
				if (over) return;
				
				//è·å–æ­£ç¡®åæ ‡
				let x = ~~(ev.offsetX / gblock.width);
				let y = ~~(ev.offsetY / gblock.width);
				let xy = x + '-' + y;
				
				// ç¬¬ä¸€æ¬¡ç‚¹å‡»
				if (gamestart == 0) {
					gamestart = 1;
					startTimer();
					setMine(xy); // ä¼ å…¥ç¬¬ä¸€æ¬¡ç‚¹å‡»çš„åæ ‡
				}
				
				if (g_info[xy].open == 0) {
					g_info[xy].open = 1;
					drawBlock(xy, g_color.open);
					markText(xy, g_info[xy].mark);
					if (g_info[xy].mark == 0) {
						openZero(xy);
					} else if (g_info[xy].mark == -1) {
						drawBlock(xy, g_color.bomb);
						markText(xy, mine[0]);
						markText(xy, mine[3]);
						checkOver(true);
					}
				}
			}

			function openZero(xy) {//é€’å½’æ¸…é›¶,é‡åˆ°0å—è¯´æ˜å‘¨è¾¹å®‰å…¨,å¯ä»¥å…¨éƒ¨æ‰“å¼€
				getAround(xy).forEach(n => {
					if (g_info[n].open == 0) {
						g_info[n].open = 1;
						drawBlock(n, g_color.open);
						markText(n, g_info[n].mark);
						if (g_info[n].mark == 0) openZero(n);
					}
				});
			}

			function checkOver(bomb) {
				over = true;
				clearInterval(ttimer);
				win = bomb ? false : mine_arr.every(xy => g_info[xy].mark == g_info[xy].open);
				
				const modal = document.getElementById('gameOverModal');
				const modalTitle = document.getElementById('modalTitle');
				const modalMessage = document.getElementById('modalMessage');
				const restartButton = document.getElementById('restartButton');
				
				if (win) {
					modalTitle.innerHTML = 'ğŸ‰ æ­å–œèƒœåˆ©ï¼';
					modalTitle.className = 'modal-title win-message';
					modalMessage.innerHTML = `ç”¨æ—¶ï¼š<strong>${(durtime/10).toFixed(1)}</strong> ç§’`;
				} else {
					modalTitle.innerHTML = 'ğŸ’£ æ¸¸æˆç»“æŸ';
					modalTitle.className = 'modal-title lose-message';
					modalMessage.innerHTML = 'åˆ«ç°å¿ƒï¼Œå†è¯•ä¸€æ¬¡ï¼';
				}

				modal.style.display = 'flex';
				
				restartButton.onclick = () => {
					modal.style.display = 'none';
					g_init();
				};

				// ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨ä¹Ÿå¯ä»¥å…³é—­
				modal.onclick = (e) => {
					if (e.target === modal) {
						modal.style.display = 'none';
						g_init();
					}
				};
			}

			function markMine(ev) {//å³é”®æ ‡æ³¨é›·å—
				//ç¦ç”¨å³é”®çš„æµè§ˆå™¨é»˜è®¤èœå•:é˜»æ­¢é»˜è®¤åŠ¨ä½œ
				ev.preventDefault();
				if (over) return;
				if (gamestart == 0) {
					gamestart = 1;
					startTimer();
				}
				//è·å–æ­£ç¡®åæ ‡
				let x = ~~(ev.offsetX / gblock.width);
				let y = ~~(ev.offsetY / gblock.width);
				let xy = x + '-' + y;
				if (g_info[xy].open == 0) {//å¦‚æœæ˜¯æœªæ‰“å¼€å—, æ ‡æ³¨é›·-1
					g_info[xy].open = -1;
					drawBlock(xy, g_color.mine);
					markText(xy, mine[1]);
					count++;
					mine_total.value = g[2] - count;
					if (count == g[2]) checkOver();
				} else if (g_info[xy].open == -1) {//å¦‚æœå·²æ ‡æ³¨é›·-1, åˆ™æ ‡æ³¨ä¸ºç–‘ä¼¼é›·-2
					g_info[xy].open = -2;
					drawBlock(xy, g_color.mine);
					markText(xy, mine[2]);
					count--;
					mine_total.value = g[2] - count;
				} else if (g_info[xy].open == -2) {//å¦‚æœæ ‡æ³¨ç–‘ä¼¼é›·-2, åˆ™æ¢å¤æœªæ‰“å¼€çŠ¶æ€0
					g_info[xy].open = 0;
					drawBlock(xy, g_color.block);
				}
			}

			function initTouchEvents() {
				let touchStartTime = 0;
				let touchTimeout;
				let lastTap = 0;
				
				canv.addEventListener('touchstart', function(e) {
					e.preventDefault();
					touchStartTime = Date.now();
					
					const touch = e.touches[0];
					const x = ~~(touch.pageX - canv.offsetLeft) / gblock.width;
					const y = ~~(touch.pageY - canv.offsetTop) / gblock.width;
					const xy = x + '-' + y;
					
					// æ¨¡æ‹Ÿé¼ æ ‡æŒ‰ä¸‹é«˜äº®æ•ˆæœ
					if (g_info[xy] && g_info[xy].open == 1) {
						getAround(xy).forEach(n => {
							if (g_info[n].open == 0) {
								drawBlock(n, g_color.highlight);
							}
						});
					}
				});

				canv.addEventListener('touchend', function(e) {
					e.preventDefault();
					const touchDuration = Date.now() - touchStartTime;
					const touch = e.changedTouches[0];
					const x = ~~(touch.pageX - canv.offsetLeft) / gblock.width;
					const y = ~~(touch.pageY - canv.offsetTop) / gblock.width;
					const xy = x + '-' + y;

					// æ£€æµ‹åŒå‡»
					const currentTime = Date.now();
					const tapLength = currentTime - lastTap;
					lastTap = currentTime;

					if (tapLength < 500) {
						// åŒå‡» - æ¨¡æ‹Ÿå³é”®æ ‡è®°
						markMine({
							preventDefault: () => {},
							offsetX: x * gblock.width,
							offsetY: y * gblock.width
						});
					} else if (touchDuration < 500) {
						// çŸ­æŒ‰ - æ¨¡æ‹Ÿå·¦é”®ç‚¹å‡»
						openBlock({
							offsetX: x * gblock.width,
							offsetY: y * gblock.width
						});
					} else {
						// é•¿æŒ‰ - æ¨¡æ‹Ÿå³é”®æ ‡è®°
						markMine({
							preventDefault: () => {},
							offsetX: x * gblock.width,
							offsetY: y * gblock.width
						});
					}

					// å–æ¶ˆé«˜äº®æ•ˆæœ
					if (g_info[xy] && g_info[xy].open == 1) {
						supGame({
							offsetX: x * gblock.width,
							offsetY: y * gblock.width
						});
					}
				});
			}
		</script>
	</body>
</html>